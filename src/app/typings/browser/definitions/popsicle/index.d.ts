// Generated by typings
// Source: https://raw.githubusercontent.com/typings/typed-es6-promise/94aac67ef7a14a8de8e9e1d3c1f9a26caa0d9fb1/dist/es6-promise.d.ts
declare module '~popsicle~any-promise~es6-promise/dist/es6-promise' {
export interface Thenable <R> {
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Thenable<U>;
}

export class Promise <R> implements Thenable <R> {
  /**
   * If you call resolve in the body of the callback passed to the constructor,
   * your promise is fulfilled with result object passed to resolve.
   * If you call reject your promise is rejected with the object passed to resolve.
   * For consistency and debugging (eg stack traces), obj should be an instanceof Error.
   * Any errors thrown in the constructor callback will be implicitly passed to reject().
   */
  constructor (callback: (resolve : (value?: R | Thenable<R>) => void, reject: (error?: any) => void) => void);

  /**
   * onFulfilled is called when/if "promise" resolves. onRejected is called when/if "promise" rejects.
   * Both are optional, if either/both are omitted the next onFulfilled/onRejected in the chain is called.
   * Both callbacks have a single parameter , the fulfillment value or rejection reason.
   * "then" returns a new promise equivalent to the value you return from onFulfilled/onRejected after being passed through Promise.resolve.
   * If an error is thrown in the callback, the returned promise rejects with that error.
   *
   * @param onFulfilled called when/if "promise" resolves
   * @param onRejected called when/if "promise" rejects
   */
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Promise<U>;
  then <U> (onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Promise<U>;

  /**
   * Sugar for promise.then(undefined, onRejected)
   *
   * @param onRejected called when/if "promise" rejects
   */
  catch <U> (onRejected?: (error: any) => U | Thenable<U>): Promise<U>;

  /**
   * Make a new promise from the thenable.
   * A thenable is promise-like in as far as it has a "then" method.
   */
  static resolve (): Promise<void>;
  static resolve <R> (value: R | Thenable<R>): Promise<R>;

  /**
   * Make a promise that rejects to obj. For consistency and debugging (eg stack traces), obj should be an instanceof Error
   */
  static reject <R> (error: any): Promise<R>;

  /**
   * Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
   * the array passed to all can be a mixture of promise-like objects and other objects.
   * The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
   */
   static all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>, T10 | Thenable<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
   static all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>, T9 | Thenable<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
   static all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>, T8 | Thenable<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;
   static all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>, T7 | Thenable<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;
   static all<T1, T2, T3, T4, T5, T6>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>, T6 | Thenable<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;
   static all<T1, T2, T3, T4, T5>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>, T5 | Thenable<T5>]): Promise<[T1, T2, T3, T4, T5]>;
   static all<T1, T2, T3, T4>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>, T4 | Thenable <T4>]): Promise<[T1, T2, T3, T4]>;
  static all<T1, T2, T3>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>, T3 | Thenable<T3>]): Promise<[T1, T2, T3]>;
  static all<T1, T2>(values: [T1 | Thenable<T1>, T2 | Thenable<T2>]): Promise<[T1, T2]>;
  static all<T1>(values: [T1 | Thenable<T1>]): Promise<[T1]>;
  static all<TAll>(values: Array<TAll | Thenable<TAll>>): Promise<TAll[]>;

  /**
   * Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
   */
  static race <R> (promises: (R | Thenable<R>)[]): Promise<R>;
}

/**
 * The polyfill method will patch the global environment (in this case to the Promise name) when called.
 */
export function polyfill (): void;
}
declare module '~popsicle~any-promise~es6-promise' {
export * from '~popsicle~any-promise~es6-promise/dist/es6-promise';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typings/typed-any-promise/74ba6cf22149ff4de39c2338a9cb84f9ded6f042/index.d.ts
declare module '~popsicle~any-promise/index' {
import { Promise } from '~popsicle~any-promise~es6-promise';

export = Promise;
}
declare module '~popsicle~any-promise' {
import main = require('~popsicle~any-promise/index');
export = main;
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/base.d.ts
declare module '~popsicle/dist/base' {
import { Url } from 'url';
export interface Query {
    [key: string]: string | string[];
}
export interface Headers {
    [name: string]: string | string[];
}
export type RawHeaders = string[];
export interface BaseOptions {
    url?: string;
    query?: string | Query;
    headers?: Headers;
    rawHeaders?: RawHeaders;
}
export default class Base {
    Url: Url;
    rawHeaders: RawHeaders;
    constructor({url, headers, rawHeaders, query}: BaseOptions);
    url: string;
    query: string | Query;
    headers: Headers;
    set(name: string, value: string | string[]): Base;
    append(name: string, value: string | string[]): this;
    name(name: string): string;
    get(name: string): string;
    remove(name: string): this;
    type(): string;
    type(value: string): Base;
}
}
declare module 'popsicle/dist/base' {
export * from '~popsicle/dist/base';
export { default } from '~popsicle/dist/base';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/request.d.ts
declare module '~popsicle/dist/request' {
import Promise = require('~popsicle~any-promise');
import Base, { BaseOptions, Headers } from '~popsicle/dist/base';
import Response, { ResponseOptions } from '~popsicle/dist/response';
import PopsicleError from '~popsicle/dist/error';
export interface DefaultsOptions extends BaseOptions {
    url?: string;
    method?: string;
    timeout?: number;
    body?: any;
    options?: any;
    use?: Middleware[];
    before?: RequestPluginFunction[];
    after?: ResponsePluginFunction[];
    always?: RequestPluginFunction[];
    progress?: RequestPluginFunction[];
    transport?: TransportOptions;
}
export interface RequestOptions extends DefaultsOptions {
    url: string;
}
export interface RequestJSON {
    url: string;
    headers: Headers;
    body: any;
    timeout: number;
    options: any;
    method: string;
}
export interface TransportOptions {
    open: OpenHandler;
    abort?: AbortHandler;
    use?: Middleware[];
}
export type Middleware = (request?: Request) => any;
export type RequestPluginFunction = (request?: Request) => any;
export type ResponsePluginFunction = (response?: Response) => any;
export type OpenHandler = (request: Request) => Promise<ResponseOptions>;
export type AbortHandler = (request: Request) => any;
export default class Request extends Base implements Promise<Response> {
    method: string;
    timeout: number;
    body: any;
    options: any;
    response: Response;
    raw: any;
    errored: PopsicleError;
    transport: TransportOptions;
    aborted: boolean;
    timedout: boolean;
    opened: boolean;
    started: boolean;
    uploadLength: number;
    downloadLength: number;
    private _uploadedBytes;
    private _downloadedBytes;
    private _promise;
    private _before;
    private _after;
    private _always;
    private _progress;
    constructor(options: RequestOptions);
    use(fn: Middleware | Middleware[]): this;
    error(message: string, code: string, original?: Error): PopsicleError;
    then(onFulfilled: (response?: Response) => any, onRejected?: (error?: PopsicleError) => any): Promise<any>;
    catch(onRejected: (error?: PopsicleError) => any): Promise<any>;
    exec(cb: (err: PopsicleError, response?: Response) => any): void;
    toOptions(): RequestOptions;
    toJSON(): RequestJSON;
    clone(): Request;
    progress(fn: RequestPluginFunction | RequestPluginFunction[]): Request;
    before(fn: RequestPluginFunction | RequestPluginFunction[]): Request;
    after(fn: ResponsePluginFunction | ResponsePluginFunction[]): Request;
    always(fn: RequestPluginFunction | RequestPluginFunction[]): Request;
    abort(): this;
    uploaded: number;
    downloaded: number;
    completed: number;
    completedBytes: number;
    totalBytes: number;
    uploadedBytes: number;
    downloadedBytes: number;
}
}
declare module 'popsicle/dist/request' {
export * from '~popsicle/dist/request';
export { default } from '~popsicle/dist/request';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/response.d.ts
declare module '~popsicle/dist/response' {
import Base, { BaseOptions, Headers, RawHeaders } from '~popsicle/dist/base';
import Request from '~popsicle/dist/request';
import PopsicleError from '~popsicle/dist/error';
export interface ResponseOptions extends BaseOptions {
    body: any;
    status: number;
    statusText: string;
}
export interface ResponseJSON {
    headers: Headers;
    rawHeaders: RawHeaders;
    body: any;
    url: string;
    status: number;
    statusText: string;
}
export default class Response extends Base {
    status: number;
    statusText: string;
    body: any;
    request: Request;
    constructor(options: ResponseOptions);
    statusType(): number;
    error(message: string, type: string, error?: Error): PopsicleError;
    toJSON(): ResponseJSON;
}
}
declare module 'popsicle/dist/response' {
export * from '~popsicle/dist/response';
export { default } from '~popsicle/dist/response';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/plugins/common.d.ts
declare module '~popsicle/dist/plugins/common' {
import Request from '~popsicle/dist/request';
export function headers(): (request: Request) => void;
export function stringify(): (request: Request) => void;
export function parse(): (request: Request) => void;
}
declare module 'popsicle/dist/plugins/common' {
export * from '~popsicle/dist/plugins/common';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/plugins/browser.d.ts
declare module '~popsicle/dist/plugins/browser' {
export * from '~popsicle/dist/plugins/common';
import { Middleware } from '~popsicle/dist/request';
export const defaults: Middleware[];
}
declare module 'popsicle/dist/plugins/browser' {
export * from '~popsicle/dist/plugins/browser';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/browser/form-data.d.ts
declare module '~popsicle/dist/browser/form-data' {
export = FormData;
}
declare module 'popsicle/dist/browser/form-data' {
import main = require('~popsicle/dist/browser/form-data');
export = main;
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/form.d.ts
declare module '~popsicle/dist/form' {
import FormData = require('~popsicle/dist/browser/form-data');
export default function form(obj: any): FormData;
}
declare module 'popsicle/dist/form' {
export * from '~popsicle/dist/form';
export { default } from '~popsicle/dist/form';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/browser/tough-cookie.d.ts
declare module '~popsicle/dist/browser/tough-cookie' {
var _default: () => void;
export = _default;
}
declare module 'popsicle/dist/browser/tough-cookie' {
import main = require('~popsicle/dist/browser/tough-cookie');
export = main;
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/jar.d.ts
declare module '~popsicle/dist/jar' {
import { CookieJar } from '~popsicle/dist/browser/tough-cookie';
export default function cookieJar(store?: any): CookieJar;
}
declare module 'popsicle/dist/jar' {
export * from '~popsicle/dist/jar';
export { default } from '~popsicle/dist/jar';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typings/typed-make-error/310953e35a2c6927b5743dc2d2215384d056fa7a/index.d.ts
declare module '~popsicle~make-error-cause~make-error/index' {
/**
 * Create a new error constructor instance.
 */
function makeError(name: string): makeError.Constructor<makeError.BaseError>;

/**
 * Set the constructor prototype to `BaseError`.
 */
function makeError<T extends Error>(super_: { new (...args: any[]): T }): makeError.Constructor<T & makeError.BaseError>;

/**
 * Create a specialized error instance.
 */
function makeError<T extends Error>(name: string | Function, super_: { new (...args: any[]): T }): makeError.Constructor<T>;

module makeError {
  /**
   * Use with ES6 inheritance.
   */
  export class BaseError implements Error {
    message: string;
    name: string;
    stack: string;

    constructor(message: string);
  }

  export interface Constructor <T> {
    new (message: string): T
    super_: any
    prototype: T
  }
}

export = makeError;
}
declare module '~popsicle~make-error-cause~make-error' {
import main = require('~popsicle~make-error-cause~make-error/index');
export = main;
}

// Generated by typings
// Source: ../../node_modules/make-error-cause/dist/index.d.ts
declare module '~popsicle~make-error-cause/dist/index' {
import makeError = require('~popsicle~make-error-cause~make-error');
function makeErrorCause(value: string | Function): makeErrorCause.Constructor<makeErrorCause.BaseError>;
namespace makeErrorCause {
    class BaseError extends makeError.BaseError {
        cause: Error;
        constructor(message: string, cause?: Error);
        toString(): string;
    }
    interface Constructor<T> {
        new (message: string, cause?: Error): T;
        super_: any;
        prototype: T;
    }
}
export = makeErrorCause;
}
declare module '~popsicle~make-error-cause' {
import main = require('~popsicle~make-error-cause/dist/index');
export = main;
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/error.d.ts
declare module '~popsicle/dist/error' {
import makeErrorCause = require('~popsicle~make-error-cause');
import Request from '~popsicle/dist/request';
export default class PopsicleError extends makeErrorCause.BaseError {
    code: string;
    popsicle: Request;
    name: string;
    constructor(message: string, code: string, original: Error, popsicle: Request);
}
}
declare module 'popsicle/dist/error' {
export * from '~popsicle/dist/error';
export { default } from '~popsicle/dist/error';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/browser.d.ts
declare module '~popsicle/dist/browser' {
import Promise = require('~popsicle~any-promise');
import Request from '~popsicle/dist/request';
import { defaults as use } from '~popsicle/dist/plugins/browser';
export { open, abort, use };
function open(request: Request): Promise<{}>;
function abort(request: Request): void;
}
declare module 'popsicle/dist/browser' {
export * from '~popsicle/dist/browser';
}

// Generated by typings
// Source: ../../node_modules/popsicle/dist/common.d.ts
declare module '~popsicle/dist/common' {
import Request, { RequestOptions, DefaultsOptions } from '~popsicle/dist/request';
import Response from '~popsicle/dist/response';
import * as plugins from '~popsicle/dist/plugins/browser';
import form from '~popsicle/dist/form';
import jar from '~popsicle/dist/jar';
import PopsicleError from '~popsicle/dist/error';
import * as transport from '~popsicle/dist/browser';
export function defaults(defaultsOptions: DefaultsOptions): (options: RequestOptions | string) => Request;
export const browser: boolean;
export const request: (options: RequestOptions | string) => Request;
export const get: (options: RequestOptions | string) => Request;
export const post: (options: RequestOptions | string) => Request;
export const put: (options: RequestOptions | string) => Request;
export const patch: (options: RequestOptions | string) => Request;
export const del: (options: RequestOptions | string) => Request;
export const head: (options: RequestOptions | string) => Request;
export { Request, Response, PopsicleError, plugins, form, jar, transport };
export default request;
}
declare module 'popsicle/dist/common' {
export * from '~popsicle/dist/common';
export { default } from '~popsicle/dist/common';
}
declare module 'popsicle' {
export * from '~popsicle/dist/common';
export { default } from '~popsicle/dist/common';
}
